// Package commands holds commands
package commands

import (
	"context"
	"database/sql"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"

	db "github.com/mmycroft/gator/internal/database"
	fd "github.com/mmycroft/gator/internal/feed"
	st "github.com/mmycroft/gator/internal/state"
)

type Command struct {
	Name string   `json:"name"`
	Args []string `json:"args"`
}

type Commands struct {
	Commands map[string]func(*st.State, Command) error
}

func HandlerLogin(state *st.State, command Command) error {
	if len(command.Args) < 1 {
		return fmt.Errorf("not enough args to retrieve username")
	}

	user, err := state.Db.GetUser(context.Background(), command.Args[0])
	if err != nil {
		return fmt.Errorf("error getting user from cfg: %w", err)
	}

	err = state.Cfg.SetUser(user.Name)
	if err != nil {
		return fmt.Errorf("error setting user on cfg: %w", err)
	}

	fmt.Printf("set user %s %v: %v\n", user.Name, user.ID, user)

	return nil
}

func HandlerRegister(state *st.State, command Command) error {
	if len(command.Args) < 1 {
		return fmt.Errorf("not enough args to retrieve username")
	}

	userName := command.Args[0]

	id := uuid.New()
	now := time.Now()

	userParams := db.CreateUserParams{
		ID:        id,
		CreatedAt: now,
		UpdatedAt: now,
		Name:      userName,
	}

	user, err := state.Db.CreateUser(context.Background(), userParams)
	if err != nil {
		return fmt.Errorf("error creating user in database: %w", err)
	}

	err = state.Cfg.SetUser(userName)
	if err != nil {
		return fmt.Errorf("error setting user in database: %w", err)
	}

	fmt.Printf("created user %s: %v\n", user.Name, user)

	return nil
}

func HandlerReset(state *st.State, command Command) error {
	err := state.Db.DeleteUsers(context.Background())
	if err != nil {
		return fmt.Errorf("error removing users from database: %w", err)
	}

	fmt.Println("reset database")

	return nil
}

func HandlerUsers(state *st.State, command Command) error {
	users, err := state.Db.GetUsers(context.Background())
	if err != nil {
		return fmt.Errorf("error getting users from database: %w", err)
	}

	for i, user := range users {
		var label string
		if state.Cfg.CurrentUserName == user.Name {
			label = "(current)"
		}
		fmt.Println(i+1, user.Name, label)
	}
	return nil
}

func HandlerAgg(state *st.State, command Command) error {
	if len(command.Args) < 1 {
		return fmt.Errorf("not enough args to retrieve duration string")
	}

	duration := command.Args[0]

	timeBetweenReqs, err := time.ParseDuration(duration)
	if err != nil {
		return fmt.Errorf("error parsing %s into a time duration: %w", duration, err)
	}

	ticker := time.NewTicker(timeBetweenReqs)
	defer ticker.Stop()

	ctx := context.Background()

	for ; ; <-ticker.C {

		feed, err := state.Db.GetNextFeedToFetch(ctx)
		if err != nil {
			return fmt.Errorf("error getting feed from database: %w", err)
		}

		err = state.Db.MarkFeedFetched(ctx, feed.ID)
		if err != nil {
			return fmt.Errorf("error marking feed fetched from database: %w", err)
		}

		rss, err := fd.FetchFeed(ctx, feed.Url)
		if err != nil {
			return fmt.Errorf("error fetching rss feed: %w", err)
		}

		for _, item := range rss.Channel.Item {

			now := time.Now()

			postParams := db.CreatePostParams{
				ID:          uuid.New(),
				CreatedAt:   now,
				UpdatedAt:   now,
				Title:       item.Title,
				Url:         item.Link,
				Description: nullString(item.Description),
				PublishedAt: nullTime(item.PubDate),
				FeedID:      feed.ID,
			}

			post, err := state.Db.CreatePost(ctx, postParams)
			if err != nil {
				var pqErr *pq.Error
				uniqueViolation := "23505"
				if errors.As(err, &pqErr) && pqErr.Code == uniqueViolation {
					fmt.Printf("Post with URL %s already exists\n", item.Link)
					continue

				}
				return fmt.Errorf("error creating post in database: %w", err)
			}

			fmt.Printf("added %s to the database\n", post.Title)
		}
	}
}

func nullString(s string) sql.NullString {
	return sql.NullString{
		String: s,
		Valid:  s != "",
	}
}

func nullTime(s string) sql.NullTime {
	layouts := []string{
		time.RFC1123Z,
		time.RFC1123,
		time.RFC822Z,
		time.RFC822,
		time.RFC3339,
		"2006-01-02T15:04:05-07:00",
		"2006-01-02T15:04:05Z07:00",
		"2006-01-02 15:04:05",
		"2006-01-02",
	}

	s = strings.TrimSpace(s)

	var t time.Time
	for _, layout := range layouts {
		if parsedTime, err := time.Parse(layout, s); err == nil {
			t = parsedTime
			break
		}
	}

	return sql.NullTime{
		Time:  t,
		Valid: !t.IsZero(),
	}
}

func HandlerBrowse(state *st.State, command Command, user db.User) error {
	limit := 2
	if len(command.Args) > 0 {
		value, err := strconv.Atoi(command.Args[0])
		if err == nil && value > 0 {
			limit = value
		}
	}

	getPostsForUserParams := db.GetPostsForUserParams{
		UserID: user.ID,
		Limit:  int32(limit),
	}

	posts, err := state.Db.GetPostsForUser(context.Background(), getPostsForUserParams)
	if err != nil {
		return fmt.Errorf("error getting posts for user: %w", err)
	}

	for i, post := range posts {
		fmt.Println(i, post.Title)
	}

	return nil
}

func HandlerAddFeed(state *st.State, command Command, user db.User) error {
	if len(command.Args) < 2 {
		return fmt.Errorf("no enough arguments to retrieve feed name and url")
	}

	name := command.Args[0]
	url := command.Args[1]

	id := uuid.New()
	now := time.Now()

	feedParams := db.CreateFeedParams{
		ID:        id,
		CreatedAt: now,
		UpdatedAt: now,
		Name:      name,
		Url:       url,
		UserID:    user.ID,
	}

	ctx := context.Background()

	feed, err := state.Db.CreateFeed(ctx, feedParams)
	if err != nil {
		return fmt.Errorf("error creating feed in database: %w", err)
	}

	fmt.Printf("created feed %s: %v\n", feed.Name, feed)

	id = uuid.New()
	now = time.Now()

	feedFollowParams := db.CreateFeedFollowParams{
		ID:        id,
		CreatedAt: now,
		UpdatedAt: now,
		UserID:    user.ID,
		FeedID:    feed.ID,
	}

	feedFollow, err := state.Db.CreateFeedFollow(ctx, feedFollowParams)
	if err != nil {
		return fmt.Errorf("error creating feed follow in database: %w", err)
	}

	fmt.Printf("created feed follow %s for %s: %v\n", feedFollow.ID, feedFollow.UserName, feedFollow)

	return nil
}

func HandlerFeeds(state *st.State, command Command) error {
	feeds, err := state.Db.GetFeeds(context.Background())
	if err != nil {
		return fmt.Errorf("error getting feeds from database: %w", err)
	}

	for i, feed := range feeds {
		fmt.Println(i+1, feed.Name, feed.Url, feed.UserName)
	}
	return nil
}

func HandlerFollow(state *st.State, command Command, user db.User) error {
	if len(command.Args) < 1 {
		return fmt.Errorf("not enough args to retrieve url")
	}

	ctx := context.Background()

	url := command.Args[0]
	feed, err := state.Db.GetFeedByUrl(ctx, url)
	if err != nil {
		return fmt.Errorf("error retrieving feed by url %s from database: %w", url, err)
	}

	id := uuid.New()
	now := time.Now()

	feedFollowParams := db.CreateFeedFollowParams{
		ID:        id,
		CreatedAt: now,
		UpdatedAt: now,
		UserID:    user.ID,
		FeedID:    feed.ID,
	}

	feedFollow, err := state.Db.CreateFeedFollow(ctx, feedFollowParams)
	if err != nil {
		return fmt.Errorf("error creating feed follow in database: %w", err)
	}

	fmt.Printf("created feed follow %s for %s: %v\n", feedFollow.ID, feedFollow.UserName, feedFollow)

	return nil
}

func HandlerFollowing(state *st.State, command Command, user db.User) error {
	userFeedFollows, err := state.Db.GetFeedFollowsForUser(context.Background(), user.ID)
	if err != nil {
		return fmt.Errorf("error getting feeds for user from database: %w", err)
	}

	for i, feedFollow := range userFeedFollows {
		fmt.Println(i+1, feedFollow.FeedName, feedFollow.UserName)
	}
	return nil
}

func HandlerUnfollow(state *st.State, command Command, user db.User) error {
	if len(command.Args) < 1 {
		return fmt.Errorf("not enough args to retrieve url")
	}
	feedUrl := command.Args[0]

	deleteFeedParams := db.DeleteFeedFollowParams{
		UserID: user.ID,
		Url:    feedUrl,
	}

	err := state.Db.DeleteFeedFollow(context.Background(), deleteFeedParams)
	if err != nil {
		return fmt.Errorf("error deleting feed from database: %w", err)
	}

	return nil
}

func MiddlewareLoggedIn(handler func(state *st.State, command Command, user db.User) error) func(*st.State, Command) error {
	return func(state *st.State, command Command) error {
		userName := state.Cfg.CurrentUserName
		user, err := state.Db.GetUser(context.Background(), userName)
		if err != nil {
			return fmt.Errorf("error retrieving %s from database: %w", userName, err)
		}
		return handler(state, command, user)
	}
}

func (c *Commands) Run(state *st.State, command Command) error {
	fn, ok := c.Commands[command.Name]
	if !ok {
		return fmt.Errorf("command %s is not present in commands", command.Name)
	}
	return fn(state, command)
}

func (c *Commands) Register(name string, fn func(*st.State, Command) error) {
	c.Commands[name] = fn
}
